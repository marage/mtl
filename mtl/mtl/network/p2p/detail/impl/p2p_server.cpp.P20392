#include "mtl/network/p2p/server.hpp"
#include "mtl/network/udp/protocol.hpp"
#include "mtl/network/udp/dgram.hpp"
#include "mtl/network/in_request.hpp"
#include "mtl/network/p2p/protocol.hpp"
#include <boost/asio/placeholders.hpp>
#include <boost/graph/breadth_first_search.hpp>
#include "mtl/network/p2p/detail/p2p_broadcast_task.hpp"
#include <algorithm>
#include <iostream>

template <typename AddressList>
class bfs_address_visitor : public boost::default_bfs_visitor
{
    typedef typename boost::property_traits<AddressList>::value_type T;

public:
    explicit bfs_address_visitor(AddressList& addresses)
        : addresses_(addresses)
    {
    }

    template <typename Vertex, typename Graph>
    void discover_vertex(Vertex u, const Graph & g) const
    {
        addresses_.push_back(g[u].address);
    }

    AddressList& addresses_;
};

namespace mtl {
namespace network {

using namespace udp;

namespace p2p {

const int max_sequence_count = 10000;
const int max_client_count = 10000;

Server::Server(const udp::dgram_ptr& dgram, const std::string& token)
    : Client(dgram), token_(token), next_member_seq_(0)
    , check_alive_timer_(dgram->getIOService())
{
    members_seq_range_.min = 1;
    members_seq_range_.max = 0xffffffffffffffff;
}

bool Server::open(const boost::asio::ip::udp::endpoint& endpoint, int64_t frequency)
{
    bool ret = Client::open(endpoint, frequency);
    if (ret) {
        dgram_->keep_alive_signal.connect(boost::bind(&Server::handleAlive, this, _1));

        check_alive_timer_.expires_from_now(boost::posix_time::seconds(5));
        check_alive_timer_.async_wait(boost::bind(&Server::handleCheckAliveTimeout,
                                                  boost::static_pointer_cast<Server>(shared_from_this()),
                                                  boost::asio::placeholders::error));
    }
    return ret;
}

void Server::close()
{
    dgram_->keep_alive_signal.disconnect_all_slots();
    Client::close();
}

bool Server::isClient(const boost::asio::ip::udp::endpoint& endpoint) const
{
    const std::string& name = toString(endpoint);
    return ((server_members_.find(name) != server_members_.end())
            || (client_members_.find(name) != client_members_.end()));
}

void Server::handlePacketArrival(InRequest& ireq, const boost::asio::ip::udp::endpoint& from, 
                                 int32_t milliseconds)
{
    uint32_t type = ireq.readCommand();
    if (type == PT_P2P_BROADCAST_DATA) {
        handleBroadcastDataArrival(ireq, from, milliseconds);
    } else if (type == PT_P2P_JOIN) {
        handleJoinRequest(ireq, from);
    } else if (type == PT_P2P_LEAVE) {
        handleLeaveRequest(ireq, from);
    } else if (type == PT_P2P_SEND_FAILED) {
        handleFailedReportRequest(ireq, from);
    } else {
        Client::handlePacketArrival(ireq, from, milliseconds);
        if (type == PT_P2P_JOIN_ACK) {
            uint64_t max_seq = seq_range_.min + max_client_count;
            if (max_seq < seq_range_.max) {
                members_seq_range_.min = max_seq;
                members_seq_range_.max = seq_range_.max;
                seq_range_.max = max_seq;
                next_member_seq_ = members_seq_range_.min;
            }
        }
    }
}

// protocol: token | role
void Server::handleJoinRequest(InRequest& ireq, const boost::asio::ip::udp::endpoint& from)
{
    // check token
    std::string token = ireq.readString(64);
    if (token != token_)
        return;
    boost::graph_traits<Graph>::vertex_descriptor from_vertex;
    SequenceRange seq_range = { 0, 0 };
    std::list<MemberVertex> members;
    uint8_t role = ireq.readInt8();
    if (role == CLIENT) {
        seq_range = getUsableSequenceRange(max_sequence_count);
        if (seq_range.size() > 0) {
            members = nearMembers(client_members_, from);
            // add new member
            boost::graph::VertexInfo vi(toString(from), from);
            from_vertex = boost::add_vertex(vi, graph_);
            Member member({role, from, seq_range, 0});
            client_members_.insert(std::make_pair(vi.name, member));
        }
    } else {
        seq_range = getUsableSequenceRange(max_client_count * max_sequence_count);
        if (seq_range.size() > 0) {
            members = nearMembers(server_members_, from);
            // add new member
            boost::graph::VertexInfo vi(toString(from), from);
            from_vertex = boost::add_vertex(vi, graph_);
            Member member({role, from, seq_range, 0});
            server_members_.insert(std::make_pair(vi.name, member));
        }
    }
    // join ack
    {
        OutRequest oreq(PT_P2P_JOIN_ACK, 0, RUDP_HEADER_LENGTH);
        oreq.writeInt64(seq_range.min);
        oreq.writeInt64(seq_range.max);
        if (seq_range.size() > 0) {
            // response
            oreq.writeInt16((uint16_t)members.size());
            char bytes[16];
            for (auto it = members.begin(), end = members.end(); it != end; ++it) {
                oreq.writeInt8((*it).role);
                oreq.writeBinary(toBytes((*it).address, bytes), 16);
                oreq.writeInt16((*it).address.port());
                // add an edge into the graph
                boost::add_edge(from_vertex, (*it).vertex, graph_);
            }
        }
        dgram_->sendTo(oreq, from);
    }
    // notify neighbors
    {
        OutRequest oreq(PT_P2P_ADD_NEIGHBOR, 0, RUDP_HEADER_LENGTH);
        oreq.writeInt8(role);
        char bytes[16];
        oreq.writeBinary(toBytes(from, bytes), 16);
        oreq.writeInt16(from.port());
        for (auto it = members.begin(), end = members.end(); it != end; ++it) {
            dgram_->sendTo(oreq, (*it).address);
        }
    }
}

// protocol: token
void Server::handleLeaveRequest(InRequest& ireq, const boost::asio::ip::udp::endpoint& from)
{
    // check token
    std::string token = ireq.readString(64);
    if (token != token_)
        return;

    // recycle
    const std::string& name = toString(from);
    uint8_t role = ireq.readInt8();
    if (role == CLIENT) {
        auto it = client_members_.find(name);
        if (it != client_members_.end()) {
            usable_sequences_.push_back(it->second.seq_range);
            removeMember(name, from);
            client_members_.erase(it);
        }
    } else {
        auto it = server_members_.find(name);
        if (it != server_members_.end()) {
            usable_sequences_.push_back(it->second.seq_range);
            removeMember(name, from);
            server_members_.erase(it);
        }
    }
}

// protocol: token | role | ip | port
void Server::handleFailedReportRequest(InRequest& ireq, const boost::asio::ip::udp::endpoint& from)
{
    // check token
    std::string token = ireq.readString(64);
    if (token != token_)
        return;
    uint8_t role = ireq.readInt8();
    ((void)role);
    char bytes[16] = { 0 };
    ireq.readBinary(bytes, 16);
    uint16_t port = ireq.readInt16();
    // remove edge
    if (boost::optional<Graph::vertex_descriptor> u = boost::graph::find_vertex(toString(from), graph_)) {
        boost::asio::ip::udp::endpoint to = toEndpoint(bytes, port);
        if (boost::optional<Graph::vertex_descriptor> v = boost::graph::find_vertex(toString(to), graph_)) {
            boost::remove_edge(*u, *v, graph_);
            // notify neighbor
            OutRequest oreq(PT_P2P_REMOVE_NEIGHBOR, 0, RUDP_HEADER_LENGTH);
            char bytes[16];
            oreq.writeBinary(toBytes(from, bytes), 16);
            oreq.writeInt16(from.port());
            dgram_->sendTo(oreq, to);
        }
    }
}

void Server::handleCheckAliveTimeout(const boost::system::error_code& /*e*/)
{
    for (auto it = server_members_.begin(); it != server_members_.end();) {
        if (++(it->second.alive_timeout_times) > 10) {
            removeMember(it->first, it->second.address);
            it = server_members_.erase(it);
            if (it == server_members_.end())
                continue;
        }
        ++it;
    }
    for (auto it = client_members_.begin(); it != client_members_.end();) {
        if (++(it->second.alive_timeout_times) > 10) {
            removeMember(it->first, it->second.address);
            it = client_members_.erase(it);
            if (it == client_members_.end())
                continue;
        }
        ++it;
    }
    check_alive_timer_.expires_from_now(boost::posix_time::seconds(5));
    check_alive_timer_.async_wait(boost::bind(&Server::handleCheckAliveTimeout,
                                              boost::static_pointer_cast<Server>(shared_from_this()),
                                              boost::asio::placeholders::error));
}

void Server::handleAlive(const boost::asio::ip::udp::endpoint& from)
{
    const std::string& name = toString(from);
    auto it = server_members_.find(name);
    if (it != server_members_.end()) {
        it->second.alive_timeout_times = 0;
    } else {
        it = client_members_.find(name);
        if (it != client_members_.end()) {
            it->second.alive_timeout_times = 0;
        }
    }
}

void Server::handleBroadcastDataArrival(InRequest& ireq, const boost::asio::ip::udp::endpoint& from,
                                        int32_t milliseconds)
{
    const std::string& name = toString(from);
    if (!isClient(from) || !isNeighbor(from)) {
        return;
    }

    // check whether the packet is duplicate
    uint64_t seq = ireq.readInt64();
    if (!packet_filter_.passed(seq))
        return;

    // stat big packet cost time
    uint16_t size = ireq.size();
    statCost(from, size, milliseconds);

    // notify app
    InRequest d_ireq(ireq.buffer(), ireq.size(), (ireq.begin()+P2P_DATA_HEADER_LENGTH));
    packet_arrival_signal(d_ireq, from);

    // forward data to the neighbors
    if (!neighbors_.empty() && (server_endpoint_ != from)) {
        uint16_t timeout = ireq.readInt16();
        if (timeout > milliseconds) {
            uint16_t left = timeout - (uint16_t)milliseconds;
            if (left > (milliseconds/3)) {
                OutRequest oreq(ireq.buffer(), ireq.size(), ireq.begin());
                oreq.skip(sizeof(uint64_t), SKIP_CURRENT);
                oreq.writeInt16(left);
                oreq.skip(0, SKIP_END);
                sendToNeighbors(seq, oreq, left, from);
            }
        }
    }

    // forward data to clients
    if (boost::optional<Vertex> v = boost::graph::find_vertex(name, graph_)) {
        typedef std::list<boost::asio::ip::udp::endpoint> AddressList;
        AddressList targets;
        bfs_address_visitor<AddressList> vis(targets);
        boost::breadth_first_search(graph_, *v, boost::visitor(vis));
    }
}

SequenceRange Server::getUsableSequenceRange(uint64_t size)
{
    SequenceRange r = { 0, 0 };
    for (std::list<SequenceRange>::iterator it = usable_sequences_.begin();
         it != usable_sequences_.end(); ++it) {
        if ((*it).size() == size) {
            r = *it;
            usable_sequences_.erase(it);
            return r;
        }
    }
    if (next_member_seq_ + size < members_seq_range_.max) {
        r.min = next_member_seq_;
        r.max = next_member_seq_ + size;
        next_member_seq_ = r.max;
    }
    return r;
}

int evaluateScale(const boost::asio::ip::address_v4::bytes_type& a, boost::asio::ip::address_v4::bytes_type b)
{
    int scale = 0;
    if (a[0] == b[0]) {
        scale = 2;
        if (a[1] == b[1]) {
            scale *= 2;
            if (a[2] == b[2]) {
                scale *= 2;
            }
        }
    }
    return scale;
}

std::list<Server::MemberVertex> Server::nearMembers(const std::unordered_map<std::string, Member>& members,
                                                    const boost::asio::ip::udp::endpoint& center)
{
    auto center_bytes = center.address().to_v4().to_bytes();
    std::list<MemberVertex> scale2;
    std::list<MemberVertex> scale4;
    std::list<MemberVertex> scale8;
    for (auto it = members.begin(), end = members.end(); it != end; ++it) {
        boost::optional<Vertex> u = boost::graph::find_vertex(it->first, graph_);
        Graph::degree_size_type n = boost::degree(*u, graph_);
        if (n < P2P_CLIENT_NEIGHBOR_COUNT) {
            int scale = evaluateScale(center_bytes, it->second.address.address().to_v4().to_bytes());
            if (scale == 8) {
                scale8.push_back(MemberVertex{it->second.role, it->second.address, *u});
                if (scale8.size() >= P2P_CLIENT_NEIGHBOR_COUNT)
                    break;
            } else if (scale == 4) {
                scale4.push_back(MemberVertex({it->second.role, it->second.address, *u}));
            } else if (scale == 2) {
                scale2.push_back(MemberVertex{it->second.role, it->second.address, *u});
            }
        }
    }

    if (static_cast<int>(scale8.size()) >= P2P_CLIENT_NEIGHBOR_COUNT) {
        return scale8;
    }

    int count = P2P_CLIENT_NEIGHBOR_COUNT - static_cast<int>(scale8.size());
    for (auto it = scale4.begin(), end = scale4.end(); count > 0 && it != end; ++it, --count) {
        scale8.push_back(*it);
    }

    for (auto it = scale2.begin(), end = scale2.end(); count > 0 && it != end; ++it, --count) {
        scale8.push_back(*it);
    }

    return scale8;
}

void Server::removeMember(const std::string& name, const boost::asio::ip::udp::endpoint& from)
{
    if (boost::optional<Vertex> v = boost::graph::find_vertex(name, graph_)) {
        // notify neighbors
        char bytes[16];
        OutRequest oreq(PT_P2P_REMOVE_NEIGHBOR, 0, RUDP_HEADER_LENGTH);
        oreq.writeBinary(toBytes(from, bytes), 16);
        oreq.writeInt16(from.port());
        auto p = boost::out_edges(*v, graph_);
        for (auto it = p.first; it != p.second; ++it) {
            if (boost::optional<Vertex> u = boost::target(*it, graph_)) {
                dgram_->sendTo(oreq, graph_[*u].address);
            }
        }
        // remove the vertex from the graph
        boost::remove_vertex(*v, graph_);
    }
}
}
}
}
