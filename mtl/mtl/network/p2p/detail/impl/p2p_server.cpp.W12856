#include "mtl/network/p2p/server.hpp"
#include <algorithm>
#include <iostream>
#include <boost/thread/thread.hpp>
#include <boost/graph/breadth_first_search.hpp>
#include <boost/graph/visitors.hpp>
#include <boost/asio/placeholders.hpp>
#include "mtl/network/udp/protocol.hpp"
#include "mtl/network/in_request.hpp"
#include "mtl/network/p2p/protocol.hpp"
#include "mtl/network/p2p/detail/p2p_broadcast_task.hpp"

namespace mtl {
namespace network {

using namespace udp;

namespace p2p {

const int MAX_SEQUENCE_COUNT = 10000;
const int MAX_CLIENT_COUNT = 10000;
const int MAX_EDGE_WEIGHT = 10000;

Server::Server(const udp::dgram_ptr& dgram, const std::string& token)
    : Client(dgram), token_(token), check_alive_timer_(dgram->getIOService())
{
    seq_range_.min = 1;
    seq_range_.max = MAX_SEQUENCE_COUNT;
    members_seq_range_.min = MAX_SEQUENCE_COUNT;
    members_seq_range_.max = 0xffffffffffffffff;
    next_member_seq_ = MAX_SEQUENCE_COUNT;
}

bool Server::open(const boost::asio::ip::udp::endpoint& endpoint, uint32_t frequency)
{
    bool ret = Client::open(endpoint, frequency);
    if (ret) {
        dgram_->keep_alive_signal.connect(boost::bind(&Server::handleAlive, this, _1));

        check_alive_timer_.expires_from_now(boost::posix_time::seconds(5));
        check_alive_timer_.async_wait(boost::bind(&Server::handleCheckAliveTimeout,
                                                  boost::static_pointer_cast<Server>(shared_from_this()),
                                                  boost::asio::placeholders::error));
        // activate task group
        task_group.activate();
    }
    return ret;
}

void Server::close()
{
    dgram_->keep_alive_signal.disconnect_all_slots();
    Client::close();
}

bool Server::isClient(const boost::asio::ip::udp::endpoint& endpoint) const
{
    if (boost::graph::find_vertex(toString(endpoint), graph_))
        return true;
    return false;
}

void Server::beginToBroadcast(OutRequest& oreq, int32_t timeout)
{
    boost::asio::ip::udp::endpoint from;
    mtl::task_ptr t(new BroadcastClientsTask(this, oreq, timeout, from));
    temp_tasks_mutex_.lock();
    temp_tasks_.push_back(t);
    temp_tasks_mutex_.unlock();
}

void Server::handlePacketArrival(InRequest& ireq, const boost::asio::ip::udp::endpoint& from, 
                                 int32_t milliseconds)
{
    uint32_t type = ireq.readCommand();
    if (type == PT_P2P_BROADCAST_DATA) {
        handleBroadcastData(ireq, from, milliseconds);
    } else if (type == PT_P2P_JOIN) {
        handleJoinRequest(ireq, from);
    } else if (type == PT_P2P_LEAVE) {
        handleLeaveRequest(ireq, from);
    } else if (type == PT_P2P_SEND_FAILED) {
        handleFailedReportRequest(ireq, from);
    } else {
        Client::handlePacketArrival(ireq, from, milliseconds);
        if (type == PT_P2P_JOIN_ACK) {
            uint64_t max_seq = seq_range_.min + MAX_CLIENT_COUNT;
            if (max_seq < seq_range_.max) {
                members_seq_range_.min = max_seq;
                members_seq_range_.max = seq_range_.max;
                seq_range_.max = max_seq;
                next_member_seq_ = members_seq_range_.min;
            }
        }
    }
}

void Server::handleGroupHeadArrival(InRequest& ireq, const boost::asio::ip::udp::endpoint& from,
                                    bool* passed)
{
    assert(passed);
    if (isNeighbor(from) || isClient(from)) {
        ireq.skip(HEADER_LENGTH, SKIP_CURRENT);
        uint64_t seq = ireq.readInt64();
        *passed = packet_filter_.passed(seq);
    } else {
        *passed = false;
    }
}

// protocol: token | role
void Server::handleJoinRequest(InRequest& ireq, const boost::asio::ip::udp::endpoint& from)
{
    // check token
    std::string token = ireq.readString(64);
    if (token != token_)
        return;

    // check exists
    const std::string& from_name = toString(from);
    if (members_.find(from_name) != members_.end()) {
        OutRequest oreq(PT_P2P_JOIN_ACK, 0, RUDP_HEADER_LENGTH);
        oreq.writeInt64(0);
        oreq.writeInt64(0);
        dgram_->sendTo(oreq, from);
        return;
    }

    SequenceRange seq_range = { 0, 0 };
    uint8_t role = ireq.readInt8();
    if (role == CLIENT) {
        seq_range = getUsableSequenceRange(MAX_SEQUENCE_COUNT);
    } else {
        seq_range = getUsableSequenceRange(MAX_CLIENT_COUNT * MAX_SEQUENCE_COUNT);
    }
    Vertex from_vertex;
    std::list<NearVertex> members;
    if (seq_range.size() > 0) {
        // add new member
        boost::graph::VertexInfo vi(from_name, role, from, seq_range);
        from_vertex = boost::add_vertex(vi, graph_);
        members_.insert(vi.name);
        // near members
        members = nearMembers(vi.name, P2P_NEIGHBOR_COUNT);
    }
    // join ack
    {
        OutRequest oreq(PT_P2P_JOIN_ACK, 0, RUDP_HEADER_LENGTH);
        oreq.writeInt64(seq_range.min);
        oreq.writeInt64(seq_range.max);
        if (seq_range.size() > 0) {
            // response
            oreq.writeInt16((uint16_t)members.size());
            char bytes[16];
            for (auto it = members.begin(), end = members.end(); it != end; ++it) {
                oreq.writeInt8(graph_[(*it).vertex].role);
                const auto& address = graph_[(*it).vertex].address;
                oreq.writeBinary(toBytes(address, bytes), 16);
                oreq.writeInt16(address.port());
                // add an edge into the graph
                boost::add_edge(from_vertex, (*it).vertex, (*it).weight, graph_);
            }
        }
        dgram_->sendTo(oreq, from);
    }
    // notify neighbors
    {
        OutRequest oreq(PT_P2P_ADD_NEIGHBOR, 0, RUDP_HEADER_LENGTH);
        oreq.writeInt8(1);
        oreq.writeInt8(role);
        char bytes[16];
        oreq.writeBinary(toBytes(from, bytes), 16);
        oreq.writeInt16(from.port());
        for (auto it = members.begin(), end = members.end(); it != end; ++it) {
            dgram_->sendTo(oreq, graph_[(*it).vertex].address);
        }
    }
}

// protocol: token
void Server::handleLeaveRequest(InRequest& ireq, const boost::asio::ip::udp::endpoint& from)
{
    // check token
    std::string token = ireq.readString(64);
    if (token == token_) {
        removeMember(toString(from), from);
    }
}

// protocol: token | role | ip | port
void Server::handleFailedReportRequest(InRequest& ireq, const boost::asio::ip::udp::endpoint& from)
{
    // check token
    std::string token = ireq.readString(64);
    if (token != token_)
        return;
    uint8_t role = ireq.readInt8();
    ((void)role);
    char bytes[16] = { 0 };
    ireq.readBinary(bytes, 16);
    uint16_t port = ireq.readInt16();
    boost::asio::ip::udp::endpoint to = toEndpoint(bytes, port);
    const std::string& to_name = toString(to);
    const std::string& from_name = toString(from);
    // change edge weight
    if (boost::optional<Vertex> u = boost::graph::find_vertex(from_name, graph_)) {
        if (boost::optional<Vertex> v = boost::graph::find_vertex(to_name, graph_)) {
            std::pair<Edge, bool> r = boost::edge(*u, *v, graph_);
            if (r.second) {
                boost::put(boost::get(boost::edge_weight, graph_), r.first, MAX_EDGE_WEIGHT);
            }
        }
        // other replaces neighbor
        replaceNeighbor(*u, from);
    }
    // new member
    std::list<NearVertex> members = nearMembers(from_name, 1);
    if (!members.empty()) {
        const NearVertex& nv = members.front();
        const auto& address = graph_[nv.vertex].address;
        OutRequest oreq(PT_P2P_ADD_NEIGHBOR, 0, RUDP_HEADER_LENGTH);
        oreq.writeInt8(1);
        oreq.writeInt8(graph_[nv.vertex].role);
        oreq.writeBinary(toBytes(address, bytes), 16);
        oreq.writeInt16(address.port());
        dgram_->sendTo(oreq, from);
    }
}

void Server::handleCheckAliveTimeout(const boost::system::error_code& /*e*/)
{
    std::list<Vertex> removed;
    std::pair<VertexInterator, VertexInterator> its = boost::vertices(graph_);
    for (; its.first != its.second; ++its.first) {
        if (++(graph_[*its.first].alive_timeout_times) > 10) {
            removed.push_back(*its.first);
        }
    }
    for (auto it = removed.begin(), end = removed.end(); it != end; ++it) {
        removeMember(graph_[*it].name, graph_[*it].address);
    }
    check_alive_timer_.expires_from_now(boost::posix_time::seconds(5));
    check_alive_timer_.async_wait(boost::bind(&Server::handleCheckAliveTimeout,
                                              boost::static_pointer_cast<Server>(shared_from_this()),
                                              boost::asio::placeholders::error));
}

void Server::handleAlive(const boost::asio::ip::udp::endpoint& from)
{
    if (boost::optional<Vertex> v = boost::graph::find_vertex(toString(from), graph_)) {
        graph_[*v].alive_timeout_times = 0;
    }
}

void Server::handleBroadcastData(InRequest& ireq, const boost::asio::ip::udp::endpoint& from,
                                 int32_t milliseconds)
{
    if (!isClient(from) && !isNeighbor(from)) {
        return;
    }

    uint16_t size = ireq.size();

    // check whether the packet is duplicate
    uint64_t seq = ireq.readInt64();
    if (size <= RUDP_DATA_SIZE && !packet_filter_.passed(seq))
        return;

    // stat big packet cost time
    statCost(from, size, milliseconds);

    // notify app
    InRequest d_ireq(ireq.buffer(), ireq.size(), (ireq.begin()+P2P_DATA_HEADER_LENGTH));
    packet_arrival_signal(d_ireq, from);

    // forward data to the neighbors
    uint16_t timeout = ireq.readInt16();
    if (!neighbors_.empty() && (server_endpoint_ != from)) {
        if (timeout > milliseconds) {
            uint16_t left = timeout - (uint16_t)milliseconds;
            if (left > (milliseconds/3)) {
                OutRequest oreq(ireq.buffer(), ireq.size(), ireq.begin());
                oreq.skip(sizeof(uint64_t), SKIP_CURRENT);
                oreq.writeInt16(left);
                oreq.skip(0, SKIP_END);
                mtl::task_ptr t(new BroadcastNeighborsTask(this, oreq, left, from));
                task_group_.add(t);
            }
        }
    }

    // forward data to clients
    if (timeout > milliseconds && members_.size() > 1) {
        uint16_t left = timeout - (uint16_t)milliseconds;
        OutRequest oreq(ireq.buffer(), ireq.size(), ireq.begin());
        mtl::task_ptr t(new BroadcastClientsTask(this, oreq, left, from));
        task_group_.add(t);
    }
}

SequenceRange Server::getUsableSequenceRange(uint64_t size)
{
    SequenceRange r = { 0, 0 };
    for (std::list<SequenceRange>::iterator it = usable_sequences_.begin();
         it != usable_sequences_.end(); ++it) {
        if ((*it).size() == size) {
            r = *it;
            usable_sequences_.erase(it);
            return r;
        }
    }
    if (next_member_seq_ + size < members_seq_range_.max) {
        r.min = next_member_seq_;
        r.max = next_member_seq_ + size;
        next_member_seq_ = r.max;
    }
    return r;
}

int evaluateScale(const boost::asio::ip::address_v4::bytes_type& a,
                  const boost::asio::ip::address_v4::bytes_type& b)
{
    int scale = 0;
    if (a[0] == b[0]) {
        scale = 2;
        if (a[1] == b[1]) {
            scale *= 2;
            if (a[2] == b[2]) {
                scale *= 2;
                if (a[3] == b[3]) {
                    scale *= 2;
                }
            }
        }
    }
    return scale;
}

std::list<Server::NearVertex> Server::nearMembers(const std::string& center,
                                                  uint32_t max_count) const
{
    std::list<NearVertex> scale8;
    boost::optional<Vertex> center_v = boost::graph::find_vertex(center, graph_);
    if (!center_v)
        return scale8;

    std::set<std::string>::const_iterator center_it = members_.find(center);
    if (center_it == members_.end())
        return scale8;

    std::set<std::string>::const_iterator begin = members_.begin();
    std::set<std::string>::const_iterator end = members_.end();

    std::list<NearVertex> scale2;
    std::list<NearVertex> scale4;
    auto center_bytes = graph_[*center_v].address.address().to_v4().to_bytes();
    uint8_t center_role = graph_[*center_v].role;
    int count = 0;
    boost::optional<Vertex> u;
    std::pair<Edge, bool> e;
    auto it = center_it;
    for (++it; (it != end && ++count < 20); ++it) {
        u = boost::graph::find_vertex(*it, graph_);
        if (graph_[*u].role != center_role)
            continue;
        e = boost::edge(*u, *center_v, graph_);
        if (e.second)
            continue;
        if (boost::degree(*u, graph_) < P2P_NEIGHBOR_COUNT) {
            int scale = evaluateScale(center_bytes, graph_[*u].address.address().to_v4().to_bytes());
            if (scale == 16) {
                scale8.push_back(NearVertex{*u, 1});
                if (scale8.size() >= max_count)
                    break;
            } else if (scale == 8) {
                scale4.push_back(NearVertex{*u, 2});
            } else if (scale == 4) {
                scale2.push_back(NearVertex{*u, 4});
            }
        }
    }
    if (center_it != begin) {
        count = 0;
        it = center_it;
        for (--it; (it != begin && ++count < 20); --it) {
            u = boost::graph::find_vertex(*it, graph_);
            if (boost::degree(*u, graph_) < P2P_NEIGHBOR_COUNT) {
                int scale = evaluateScale(center_bytes, graph_[*u].address.address().to_v4().to_bytes());
                if (scale == 8) {
                    scale8.push_back(NearVertex{*u, 1});
                    if (scale8.size() >= max_count)
                        break;
                } else if (scale == 4) {
                    scale4.push_back(NearVertex{*u, 2});
                } else if (scale == 2) {
                    scale2.push_back(NearVertex{*u, 4});
                }
            }
        }
    }

    if (scale8.size() >= max_count)
        return scale8;

    int n = max_count - static_cast<int>(scale8.size());
    for (auto it = scale4.begin(), end = scale4.end(); n > 0 && it != end; ++it, --n) {
        scale8.push_back(*it);
    }

    for (auto it = scale2.begin(), end = scale2.end(); n > 0 && it != end; ++it, --n) {
        scale8.push_back(*it);
    }

    return scale8;
}

void Server::removeMember(const std::string& name,
                          const boost::asio::ip::udp::endpoint& from)
{
    auto it = members_.find(name);
    if (it != members_.end()) {
        members_.erase(it);
    }
    if (boost::optional<Vertex> v = boost::graph::find_vertex(name, graph_)) {
        // recycle sequence
        const SequenceRange& sr = graph_[*v].seq_range;
        usable_sequences_.push_back(sr);
        packet_filter_.remove(sr.min, sr.max);
        // others replace neighbor
        std::pair<OutEdgeIterator, OutEdgeIterator> it_pair = boost::out_edges(*v, graph_);
        for (auto it = it_pair.first; it != it_pair.second; ++it) {
            Vertex t = boost::target(*it, graph_);
            Vertex s = boost::source(*it, graph_);
            replaceNeighbor((t != v ? t : s), from);
        }
        // remove the vertex from the graph
        boost::remove_vertex(*v, graph_);
    }
}

void Server::replaceNeighbor(Vertex v, const boost::asio::ip::udp::endpoint& neighbor)
{
    assert(v);
    char bytes[16];
    OutRequest oreq(PT_P2P_REPLACE_NEIGHBOR, 0, RUDP_HEADER_LENGTH);
    oreq.writeInt8(1);
    oreq.writeBinary(toBytes(neighbor, bytes), 16);
    oreq.writeInt16(neighbor.port());
    std::list<NearVertex> members = nearMembers(graph_[v].name, 1);
    if (!members.empty()) {
        const NearVertex& nv = members.front();
        const auto& address = graph_[nv.vertex].address;
        oreq.writeInt8(1);
        oreq.writeInt8(graph_[nv.vertex].role);
        oreq.writeBinary(toBytes(address, bytes), 16);
        oreq.writeInt16(address.port());
    }
    dgram_->sendTo(oreq, graph_[v].address);
}

// bfs visitor
class address_bfs_visitor : public boost::default_bfs_visitor
{
public:
    explicit address_bfs_visitor(std::list<boost::asio::ip::udp::endpoint>& a)
        : addresses(&a)
    {
    }

    template <typename Vertex, typename Graph>
    void discover_vertex(Vertex u, const Graph& g) const
    {
        (*addresses).push_back(g[u].address);
    }

    mutable std::list<boost::asio::ip::udp::endpoint>* addresses;
};

void Server::bfsMembers(const boost::asio::ip::udp::endpoint& start,
                        std::list<boost::asio::ip::udp::endpoint>& targets)
{
    boost::optional<Vertex> v;
    if (start.port() > 0) {
        v = boost::graph::find_vertex(toString(start), graph_);
    } else {
        if (!members_.empty()) {
            v = boost::graph::find_vertex(*members_.begin(), graph_);
        }
    }
    if (v) {
        auto m = boost::get(&boost::graph::VertexInfo::color, graph_);
        address_bfs_visitor vis(targets);
        boost::breadth_first_search(graph_, *v, boost::color_map(m).visitor(vis));
    }
}
}
}
}
